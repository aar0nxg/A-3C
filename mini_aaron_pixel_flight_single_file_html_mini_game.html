<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Aaron — Pixel Flight</title>
<style>
  html,body{height:100%;margin:0;background:#0b1220;display:flex;align-items:center;justify-content:center;font-family:Inter, system-ui, sans-serif}
  .wrap{width:900px;max-width:98vw}
  canvas{display:block;width:100%;background:#6ec1ff;border-radius:8px;image-rendering:pixelated}
  .ui{display:flex;justify-content:space-between;align-items:center;margin-top:8px;color:#fff}
  .button{background:#ff6b81;padding:8px 14px;border-radius:10px;cursor:pointer;user-select:none}
  .button:active{transform:translateY(1px)}
  .small{font-size:14px;color:#dbeafe}
  .controls{font-size:13px;color:#e9f5ff}
  .footer{margin-top:10px;color:#9fbbe6;font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="800" height="450"></canvas>
  <div class="ui">
    <div>
      <div class="button" id="startBtn">Play</div>
    </div>
    <div class="controls small">Controls: Arrow Up / Arrow Down or Tap to move • Reach Canada!</div>
    <div class="small" id="status">Distance: 0%</div>
  </div>
  <div class="footer">Pixel mini-game — fly from Bangladesh to Canada and avoid obstacles. Made for you ❤️</div>
</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  // pixel aesthetic
  ctx.imageSmoothingEnabled = false;

  const W = canvas.width, H = canvas.height;
  let running = false;
  let gameState = 'idle'; // idle, playing, ended

  // Scale factor for drawing 'pixels'
  const px = 4; // pixel size

  // Simple pixel-sprite helpers
  function drawPixelSprite(x,y,map,scale=1){
    for(let yy=0; yy<map.length; yy++){
      for(let xx=0; xx<map[yy].length; xx++){
        const c = map[yy][xx];
        if(!c) continue;
        ctx.fillStyle = c;
        ctx.fillRect((x + xx*px*scale)|0, (y + yy*px*scale)|0, px*scale, px*scale);
      }
    }
  }

  // Mini Aaron plane sprite (simple)
  const planeSprite = [
    [null,null,'#ffffff','#ffffff','#ffffff',null,null],
    [null,'#ffcc00','#ffcc00','#ffcc00','#ffcc00','#ffcc00',null],
    ['#ffcc00','#333333','#333333','#333333','#333333','#333333','#ffcc00'],
    [null,null,'#ffcc00','#ffcc00','#ffcc00',null,null],
  ];

  // Mini characters for end-screen (very simple)
  const aaronSprite = [
    [null,'#111111','#111111',null],
    ['#111111','#f0c0b8','#f0c0b8','#111111'],
    [null,'#111111','#111111',null]
  ];
  const chandrimaSprite = [
    [null,'#111111','#111111',null],
    ['#111111','#ffd1e6','#ffd1e6','#111111'],
    [null,'#111111','#111111',null]
  ];

  // Background layers
  const stars = Array.from({length:120}).map(()=>({x:Math.random()*W,y:Math.random()*H*0.6,size:Math.random()*2+0.5}));
  const clouds = [];

  function spawnCloud(){
    clouds.push({x:W + 50, y:50 + Math.random()*180, speed:0.3 + Math.random()*0.6, size: 40 + Math.random()*60});
  }
  for(let i=0;i<4;i++) spawnCloud();

  // Obstacles
  const obstacles = [];
  function spawnObstacle(){
    const type = Math.random() < 0.6 ? 'bird' : (Math.random()<0.5?'storm':'balloon');
    const y = 60 + Math.random()*(H-120);
    const speed = 2 + Math.random()*2 + (progress/50);
    obstacles.push({x:W + 40, y, type, speed, w:30, h:18});
  }

  // player
  const player = {x:100, y:H/2, vy:0, w:36, h:20};

  // progress to Canada
  let distance = 0; // 0..100
  let progress = 0; // same
  const goal = 100;

  // input
  const keys = {};
  window.addEventListener('keydown', e=>{keys[e.key]=true; if(e.key==='ArrowUp' || e.key==='ArrowDown') e.preventDefault()});
  window.addEventListener('keyup', e=>{keys[e.key]=false});
  canvas.addEventListener('pointerdown', e=>{keys['pointer']=true});
  canvas.addEventListener('pointerup', e=>{keys['pointer']=false});

  // Start button
  document.getElementById('startBtn').addEventListener('click', startGame);

  // Game loop
  let last = performance.now();
  let spawnTimer = 0;

  function startGame(){
    obstacles.length = 0;
    clouds.length = 0;
    for(let i=0;i<4;i++) spawnCloud();
    distance = 0;
    progress = 0;
    player.y = H/2;
    player.vy = 0;
    spawnTimer = 0;
    gameState = 'playing';
    document.getElementById('status').textContent = 'Distance: 0%';
    running = true;
    loop(performance.now());
  }

  function endGame(success){
    running = false;
    gameState = success ? 'ended' : 'idle';
    if(success) showEnding();
  }

  function showEnding(){
    // animate two sprites meeting
    let t0 = performance.now();
    const duration = 3800;
    const startA = {x: -60, y: H/2 + 10};
    const startC = {x: W + 60, y: H/2 + 10};
    function anim(now){
      const p = Math.min(1, (now - t0)/duration);
      renderFrame(true, {phase:p, aPos:{x: startA.x + (W/2 - 40 - startA.x)*easeOut(p), y:startA.y}, cPos:{x: startC.x + (W/2 + 40 - startC.x)*easeOut(p), y:startC.y}});
      if(p < 1) requestAnimationFrame(anim);
      else {
        // hug pulse
        pulseHearts();
      }
    }
    requestAnimationFrame(anim);
  }

  function pulseHearts(){
    let n=0; const max=8;
    function ph(){
      renderFrame(true, {phase:1, hugPulse: n});
      n++;
      if(n<max) setTimeout(ph,260);
    }
    ph();
  }

  function renderFrame(ending=false, opts={}){
    // clear sky gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#6ec1ff');
    g.addColorStop(0.6,'#cfecff');
    g.addColorStop(1,'#ffe6f2');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // distant land strip at bottom to show travel
    ctx.fillStyle = '#2e5a3a';
    ctx.fillRect(0, H-50, W, 50);

    // stars at top (glimmering)
    for(const s of stars){
      ctx.fillStyle = '#fff';
      ctx.fillRect((s.x|0), (s.y|0), Math.max(1,s.size|0), Math.max(1,s.size|0));
    }

    // clouds
    for(const c of clouds){
      ctx.globalAlpha = 0.9;
      roundedCloud(c.x, c.y, c.size);
      ctx.globalAlpha = 1;
    }

    // obstacles
    for(const o of obstacles){
      drawObstacle(o);
    }

    // plane
    drawPixelSprite(player.x, player.y-8, planeSprite, 1);

    // HUD
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(10,10,220,36);
    ctx.fillStyle = '#fff';
    ctx.font = '14px monospace';
    ctx.fillText('Journey: Bangladesh → Canada',16,28);
    const pct = Math.min(100, Math.round(progress));
    ctx.fillStyle = '#fff';
    ctx.fillText(pct + '%', 190,28);

    // progress bar
    ctx.fillStyle = '#333'; ctx.fillRect(10,44,220,8);
    ctx.fillStyle = '#6affb8'; ctx.fillRect(10,44, 2.2*pct,8);

    if(ending){
      // draw mini aaron and chandrima using opts positions
      const aPos = opts.aPos || {x: W/2-40, y: H/2+10};
      const cPos = opts.cPos || {x: W/2+40, y: H/2+10};
      drawPixelSprite(aPos.x, aPos.y, aaronSprite, 3);
      drawPixelSprite(cPos.x, cPos.y, chandrimaSprite, 3);
      // if hug pulse draw hearts
      if(opts.hugPulse !== undefined){
        const n = opts.hugPulse;
        for(let i=0;i<3;i++){
          const dx = (i-1)*24;
          const y = H/2 - 20 - i*6 - (n%2?6:0);
          drawHeart(W/2 + dx, y, 12 + (n%3));
        }
      }
      // ending title
      ctx.fillStyle = '#000a'; ctx.fillRect(W/2-170, H/2 -120, 340, 64);
      ctx.fillStyle = '#fff'; ctx.font='22px monospace'; ctx.fillText('Home — Canada', W/2-80, H/2-84);
      ctx.font='14px monospace'; ctx.fillText('Mini Aaron made it! They embrace at last ❤️', W/2-140, H/2-64);
    }
  }

  function drawObstacle(o){
    if(o.type==='bird'){
      ctx.fillStyle = '#111'; ctx.fillRect(o.x, o.y, 18,6);
      ctx.fillRect(o.x+6,o.y-6,6,6);
    } else if(o.type==='storm'){
      ctx.fillStyle='#333'; roundedCloud(o.x, o.y, 30); ctx.fillStyle='#222'; ctx.fillRect(o.x+6,o.y+20,20,6);
    } else if(o.type==='balloon'){
      ctx.fillStyle='#ff6b81'; ctx.beginPath(); ctx.ellipse(o.x+10,o.y+6,10,12,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#333'; ctx.fillRect(o.x+9,o.y+16,2,6);
    }
  }

  function roundedCloud(x,y,size){
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.ellipse(x,y,size,20,0,0,Math.PI*2);
    ctx.ellipse(x+size*0.7,y+6,size*0.7,18,0,0,Math.PI*2);
    ctx.ellipse(x-size*0.7,y+6,size*0.7,18,0,0,Math.PI*2);
    ctx.fill();
  }

  function drawHeart(cx, cy, s){
    ctx.fillStyle = '#ff6b81';
    ctx.beginPath();
    const top = s*0.5;
    ctx.moveTo(cx, cy + top);
    ctx.bezierCurveTo(cx + s, cy - s, cx + s*1.6, cy + s*0.6, cx, cy + s);
    ctx.bezierCurveTo(cx - s*1.6, cy + s*0.6, cx - s, cy - s, cx, cy + top);
    ctx.fill();
  }

  function easeOut(t){ return 1 - Math.pow(1-t,3); }

  // collision detection
  function rectsCollide(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function loop(now){
    if(!running) return;
    const dt = Math.min(40, now - last);
    last = now;

    // background updates
    for(const c of clouds){ c.x -= c.speed * (dt/16); if(c.x < -120) c.x = W + 120, c.y = 30 + Math.random()*220; }

    // spawn obstacles over time
    spawnTimer += dt;
    if(spawnTimer > 800 - Math.min(500, progress*3)){
      spawnTimer = 0; if(Math.random() < 0.9) spawnObstacle();
    }

    // update obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.x -= o.speed * (dt/16) * 1.2;
      if(o.x < -80) obstacles.splice(i,1);
    }

    // input -> velocity
    if(keys['ArrowUp'] || keys['w'] || keys['W'] || keys['pointer']){
      player.vy = -3.5;
    } else if(keys['ArrowDown'] || keys['s'] || keys['S']){
      player.vy = 3.5;
    } else {
      // gentle gravity/mid float
      player.vy *= 0.96;
    }
    player.y += player.vy * (dt/16);
    if(player.y < 32) player.y = 32; if(player.y > H-32) player.y = H-32;

    // collision boxes
    const pBox = {x:player.x, y:player.y-10, w:player.w, h:player.h};
    let hit = false;
    for(const o of obstacles){
      const oBox = {x:o.x, y:o.y, w:o.w, h:o.h};
      if(rectsCollide(pBox,oBox)) hit = true;
    }
    if(hit){
      // small knockback and slow progress
      player.x = Math.max(60, player.x - 30);
      progress = Math.max(0, progress - 4);
      // clear obstacles for a moment
      obstacles.splice(0, Math.min(3,obstacles.length));
    }

    // advance progress steadily
    progress += 0.03 * (dt/16);
    if(progress >= goal){
      progress = goal;
      running = false;
      endGame(true);
    }

    // update status text
    document.getElementById('status').textContent = 'Distance: ' + Math.min(100, Math.floor(progress)) + '%';

    // draw
    renderFrame(false);

    requestAnimationFrame(loop);
  }

  // initial draw - title screen
  function drawTitle(){
    ctx.fillStyle = '#082033'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.font = '36px monospace'; ctx.fillText('Mini Aaron — Flight', 160, 150);
    ctx.font='16px monospace'; ctx.fillText('Fly across the world from Bangladesh to Canada!', 160, 190);
    // draw plane and characters
    drawPixelSprite(120, 220, planeSprite, 1);
    drawPixelSprite(420, 200, aaronSprite, 6);
    drawPixelSprite(520, 200, chandrimaSprite, 6);
    ctx.font='14px monospace'; ctx.fillText('Press Play to Start', 160, 240);
  }

  drawTitle();

  // touch friendly: start on tap on mobile
  canvas.addEventListener('click', e=>{ if(gameState==='idle'){ startGame(); }});

})();
</script>
</body>
</html>
