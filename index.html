<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel Purple Rocket ‚Äî Love Run</title>
  <style>
    :root { --bg1:#12001f; --bg2:#2a0a4a; --fg:#e2c6ff; --accent:#b28bff; --danger:#ff6fb3; --success:#8dffca; }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";}
    #wrap{position:fixed;inset:0;display:flex;flex-direction:column;}
    #hud{display:flex;gap:.75rem;align-items:center;justify-content:space-between;padding:.75rem 1rem;font-weight:700}
    #hud .pill{background:rgba(255,255,255,.08);padding:.35rem .6rem;border-radius:999px;backdrop-filter: blur(6px); box-shadow: 0 0 0 1px rgba(255,255,255,.05) inset;}
    #game{flex:1;position:relative;}
    canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering: pixelated;image-rendering: crisp-edges;}
    #centerMsg{position:absolute;inset:0;display:none;place-items:center;pointer-events:none;text-align:center;padding:1rem;}
    #centerMsg .card{pointer-events:auto;max-width:680px;background:rgba(42,10,74,.72);border:1px solid rgba(255,255,255,.15);border-radius:18px;padding:18px 16px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
    .btn{cursor:pointer;display:inline-flex;align-items:center;gap:.5rem;padding:.6rem .9rem;border-radius:14px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:var(--fg);font-weight:700}
    .btn:hover{background:rgba(255,255,255,.14)}
    .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:.5rem}
    small{opacity:.85}
    #touchHint{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);opacity:.9;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.18);padding:.4rem .7rem;border-radius:999px;font-weight:700}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="hud">
      <div class="pill">‚è±Ô∏è <span id="timer">03:00</span></div>
      <div class="pill">‚≠ê Score: <span id="score">0</span></div>
      <div class="pill">üöÄ Speed: <span id="speed">1.0x</span></div>
      <div class="pill">üïπÔ∏è Controls: <span id="controls">Space / Tap</span></div>
    </div>
    <div id="game">
      <canvas id="c"></canvas>
      <div id="centerMsg"><div class="card" id="centerCard"></div></div>
      <div id="touchHint">TAP to thrust</div>
    </div>
  </div>

<script>
(() => {
  // ====== pixel canvas ======
  const view = document.getElementById('c');
  const ctx = view.getContext('2d');
  const W = 320, H = 180;
  const buffer = document.createElement('canvas'); buffer.width=W; buffer.height=H;
  const g = buffer.getContext('2d'); g.imageSmoothingEnabled=false; ctx.imageSmoothingEnabled=false;

  // ====== constants ======
  const DURATION = 1000; // EXACTLY 3 minutes
  const GRAVITY = 0.28;
  const FLAP = -5.4;

  // pacing (approved earlier)
  const BASE_SPEED = 0.42;
  const MAX_SPEED  = 2.0;
  const ASTEROID_INTERVAL_MIN = 750;
  const ASTEROID_INTERVAL_MAX = 2100;

  const START_GRACE = 1500;           // first 1.5s: no asteroids
  const GF_PREVIEW_WINDOW = 30000;    // last 30s: show Chandrima, unreachable preview
  const ROCKET_X = 56;

  // parallax layers (cosmetic)
  const NEBULA_COUNT   = 6;
  const PLANET_COUNT   = 2;
  const NEBULA_PARALLAX = 0.18;
  const PLANET_PARALLAX = 0.10;

  // FX (cosmetic)
  const TRAIL_MAX = 42;
  const TRAIL_SPAWN_INTERVAL = 40;
  const SPARKLE_BURST = 12;
  const SPARKLE_DRIP = 2;
  const SPARKLE_INTERVAL = 60;

  // --- Rider (HD on screen canvas) ---
  const AARON_SRC = "aaron.jpg"; // change if your file is .png
  const AARON_W   = 12;
  let   AARON_H   = 12;
  const AARON_OFF_X = 3;
  const AARON_OFF_Y = -6;
  const aaronImg = new Image();
  let aaronReady = false;
  aaronImg.onload = () => {
    const ratio = aaronImg.height / aaronImg.width;
    AARON_H = Math.max(1, Math.round(AARON_W * ratio));
    aaronReady = true;
  };
  aaronImg.src = AARON_SRC;

  // --- Girlfriend (Chandrima) HD sprite (end + preview) ---
  const GF_SRC = "chandrima.png"; // match your file exactly
  const GF_W   = 18;
  let   GF_H   = 26;
  const gfImg = new Image();
  let gfReady = false;
  gfImg.onload = () => {
    const r = gfImg.height / gfImg.width;
    GF_H = Math.max(1, Math.round(GF_W * r));
    gfReady = true;
  };
  gfImg.src = GF_SRC;

  // ====== state ======
  let playing=false, finished=false, crashed=false, startedAt=0, elapsed=0, lastFrame=0;
  let score=0;
  let rocket={x:ROCKET_X,y:H/2,vy:0,w:16,h:10,invuln:0};
  let obstacles=[]; let stars=[]; let nextAsteroidAt=0;

  // Chandrima entities
  let gfPreview=null;     // visible last 30s, not catchable
  let girlfriend=null;    // real target after 0:00

  // visual layers / fx
  let nebula = [];
  let planets = [];
  let trail = [];
  let sparkles = [];
  let lastTrailAt = 0;
  let nextSparkleAt = 0;

  // ====== ui ======
  const uiTimer=document.getElementById('timer');
  const uiScore=document.getElementById('score');
  const uiSpeed=document.getElementById('speed');
  const centerMsg=document.getElementById('centerMsg');
  const centerCard=document.getElementById('centerCard');
  const touchHint=document.getElementById('touchHint');

  // inputs
  window.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); flap(); }});
  window.addEventListener('touchstart', ()=>flap(), {passive:true});
  window.addEventListener('mousedown', ()=>flap());

  function flap(){
    if(!playing && !finished){ start(); }
    if(playing){
      rocket.vy = FLAP;
      spawnThrustBurst();
    }
  }

  // overlay helpers
  function showCenter(html){ centerCard.innerHTML=html; centerMsg.style.display='grid'; }
  function hideCenter(){ centerMsg.style.display='none'; centerCard.innerHTML=''; }

  // screens
  function showIntro(){
    const html = `
      <h2 style="margin:4px 0 10px">üíú Pixel Purple Rocket ‚Äî Love Run</h2>
      <p style="margin:0 0 8px">Fly for <b>3 minutes</b>, dodge asteroids, then at the end you reach your love.</p>
      <div class="row"><button class="btn" id="btnStart">Start (Space/Tap)</button><button class="btn" id="btnHow">How to Play</button></div>
      <small>Mobile friendly ‚Ä¢ Pixel-art vibes ‚Ä¢ Ramps steadily</small>`;
    showCenter(html);
    document.getElementById('btnStart').onclick=()=>start();
    document.getElementById('btnHow').onclick =()=>showHow();
  }
  function showHow(){
    const html=`<h3>Controls</h3>
    <ul style="text-align:left;line-height:1.5">
      <li><b>Space</b> (desktop) or <b>tap</b> (phone) to thrust up</li>
      <li>Release to fall ‚Ä¢ Avoid asteroids</li>
      <li>Last 30s: you can <i>see</i> her ahead; at 0:00 you can reach her üíû</li>
    </ul>
    <div class="row"><button class="btn" id="btnBack">Back</button></div>`;
    showCenter(html);
    document.getElementById('btnBack').onclick=()=>showIntro();
  }
  function showCrash(){ const html=`<h2>üí• Oops! You crashed</h2><p>Score: <b>${score}</b></p><div class="row"><button class="btn" id="btnRetry">Try Again</button></div>`; showCenter(html); document.getElementById('btnRetry').onclick=()=>start(); }
  function showWin(){ const html=`<h2>üíû You made it!</h2><p>You reached her after a 3-minute run. Score: <b>${score}</b></p><div class="row"><button class="btn" id="btnReplay">Replay</button></div>`; showCenter(html); document.getElementById('btnReplay').onclick=()=>start(); }

  // start/end
  function start(){
    hideCenter(); touchHint.style.display='none';
    playing=true; crashed=false; finished=false;
    score=0; obstacles=[]; stars=[];
    nebula=[]; planets=[];
    trail=[]; sparkles=[]; lastTrailAt=0; nextSparkleAt=0;

    // reset girlfriend states
    gfPreview=null;
    girlfriend=null;

    rocket.y=H/2; rocket.vy=0; rocket.invuln=800;
    startedAt=performance.now(); lastFrame=startedAt; elapsed=0; nextAsteroidAt=0;

    // seed stars & layers
    for(let i=0;i<80;i++) stars.push(newStar(Math.random()*W, Math.random()*H));
    for (let i=0;i<NEBULA_COUNT;i++) nebula.push(newNebula(Math.random()*W, Math.random()*H));
    for (let i=0;i<PLANET_COUNT;i++) planets.push(newPlanet(Math.random()*W, 20 + Math.random()*(H-40)));

    requestAnimationFrame(loop);
  }
  function endWin(){ playing=false; finished=true; showWin(); }
  function endCrash(){ playing=false; crashed=true; showCrash(); }

  // helpers
  function speedAt(t){ const k=Math.min(1,t/DURATION); const eased=k*k; return BASE_SPEED + (MAX_SPEED-BASE_SPEED)*eased; }
  function asteroidIntervalAt(t){ const k=Math.min(1,t/DURATION); return ASTEROID_INTERVAL_MAX + (ASTEROID_INTERVAL_MIN - ASTEROID_INTERVAL_MAX)*k; }
  function formatTime(ms){ const s=Math.ceil(Math.max(0,ms)/1000); const m=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }

  function newStar(x=W+8,y=Math.random()*H){ const layer=Math.random()<0.6?0:(Math.random()<0.5?1:2); return {x,y,layer}; }
  function newAsteroid(){ const r=6+Math.random()*10; const y=12+Math.random()*(H-24); const vy=(Math.random()*0.6-0.3); return {x:W+20,y,r,vy,scored:false}; }

  function spawnGirlfriend(){ // final, catchable
    girlfriend={x: (gfPreview? gfPreview.x : W+60), y: (gfPreview? gfPreview.y : H/2-10), w:GF_W, h:GF_H, sway:(gfPreview? gfPreview.sway:0)||0};
    gfPreview=null;
  }

  // ======= Visual Layer Helpers (cosmetic) =======
  function newNebula(x=W+40,y=Math.random()*H){ const r=26+Math.random()*42; const a=0.08+Math.random()*0.12; const wobble=Math.random()*Math.PI*2; return {x,y,r,a,wobble}; }
  function drawNebula(dt,spd){
    for(let i=nebula.length-1;i>=0;i--){
      const n=nebula[i];
      n.x -= spd*NEBULA_PARALLAX*dt;
      n.wobble += 0.004;
      const rr = n.r + Math.sin(n.wobble)*2.0;
      const grad = g.createRadialGradient(n.x,n.y,0,n.x,n.y,rr);
      grad.addColorStop(0,`rgba(178,139,255,${n.a})`);
      grad.addColorStop(1,`rgba(178,139,255,0)`);
      g.fillStyle = grad;
      g.beginPath(); g.arc(n.x|0,n.y|0,rr|0,0,Math.PI*2); g.fill();
      if(n.x < -rr - 10) nebula.splice(i,1);
    }
    while(nebula.length < NEBULA_COUNT) nebula.push(newNebula());
  }

  function newPlanet(x=W+80,y=30+Math.random()*(H-60)){ const r=10+Math.random()*14; const ring=Math.random()<0.5; const hue=Math.random()<0.5?'#6e49a3':'#8a68c0'; return {x,y,r,ring,hue}; }
  function drawPlanets(dt,spd){
    for(let i=planets.length-1;i>=0;i--){
      const p=planets[i];
      p.x -= spd*PLANET_PARALLAX*dt;

      g.fillStyle = `${p.hue}aa`;
      g.beginPath(); g.arc(p.x|0,p.y|0,p.r|0,0,Math.PI*2); g.fill();

      g.fillStyle = 'rgba(0,0,0,0.25)';
      g.beginPath(); g.arc((p.x+2)|0,(p.y+1)|0,p.r|0,Math.PI*0.1,Math.PI*1.1); g.fill();

      if(p.ring){
        g.strokeStyle='rgba(226,198,255,0.45)';
        g.lineWidth=1;
        g.beginPath(); g.ellipse(p.x|0,p.y|0,p.r+3,p.r*0.45,0.25,0,Math.PI*2); g.stroke();
      }
      if(p.x < -p.r - 20) planets.splice(i,1);
    }
    while(planets.length < PLANET_COUNT) planets.push(newPlanet());
  }

  // ===== Visual FX: trail & sparkles (cosmetic) =====
  function maybeAddTrail(now,spd,dt){
    if(now-lastTrailAt>=TRAIL_SPAWN_INTERVAL){
      trail.push({ x:rocket.x-3, y:rocket.y+5, r:2, a:1 });
      lastTrailAt=now; if(trail.length>TRAIL_MAX) trail.shift();
    }
    for(let i=trail.length-1;i>=0;i--){
      const p=trail[i];
      p.x-=spd*dt*0.6; p.y+=0.02*dt; p.r+=0.005*dt; p.a-=0.0035*dt;
      if(p.a<=0||p.x<-10) trail.splice(i,1);
    }
  }
  function drawTrail(){
    for(const p of trail){
      g.fillStyle = `rgba(255,154,210,${0.50*Math.max(0,p.a)})`;
      g.fillRect(p.x|0,p.y|0,2,2);
      g.fillStyle = `rgba(178,139,255,${0.35*Math.max(0,p.a)})`;
      g.fillRect((p.x-1)|0,(p.y+1)|0,1,1);
    }
  }
  function spawnThrustBurst(){ for(let i=0;i<SPARKLE_BURST;i++){ sparkles.push({x:rocket.x-2,y:rocket.y+5,vx:-0.02-Math.random()*0.10,vy:(Math.random()*0.5-0.25),life:450+Math.random()*300,a:1}); } }
  function maybeDripSparkles(now){
    if(rocket.vy<0 && now>=nextSparkleAt){
      nextSparkleAt=now+SPARKLE_INTERVAL;
      for(let i=0;i<SPARKLE_DRIP;i++){
        sparkles.push({x:rocket.x-2,y:rocket.y+5,vx:-0.02-Math.random()*0.06,vy:(Math.random()*0.4-0.2),life:380+Math.random()*220,a:1});
      }
    }
  }
  function updateSparkles(dt,spd){
    for(let i=sparkles.length-1;i>=0;i--){
      const s=sparkles[i];
      s.x += s.vx*dt - spd*dt*0.5;
      s.y += s.vy*dt;
      s.vy += 0.0006*dt;
      s.life -= dt;
      s.a = Math.max(0, s.life/450);
      if(s.life<=0 || s.x<-10) sparkles.splice(i,1);
    }
  }
  function drawSparkles(){
    for(const s of sparkles){
      g.fillStyle=`rgba(255,142,198,${0.9*s.a})`; g.fillRect(s.x|0,s.y|0,1,1);
      g.fillStyle=`rgba(226,198,255,${0.6*s.a})`; g.fillRect((s.x+1)|0,s.y|0,1,1);
    }
  }

  // ===== Girlfriend pixel-art fallback (used only if image not yet loaded) =====
  function drawGirlfriendFallback(entity){
    if(!entity) return;
    if (gfReady) return; // HD image will be drawn on screen canvas after blit
    const gx=entity.x|0, gy=entity.y|0;
    entity.sway=(entity.sway||0)+0.05;
    const sway=Math.sin(entity.sway)*1.2;
    // hair
    g.fillStyle='#2b0f46'; g.fillRect(gx+4,gy+1,10,8);
    // face
    g.fillStyle='#ffd1ea'; g.fillRect(gx+6,gy+4,6,6);
    // eyes
    g.fillStyle='#2b0f46'; g.fillRect(gx+7,gy+6,1,1); g.fillRect(gx+10,gy+6,1,1);
    // body/dress
    g.fillStyle='#b28bff'; g.fillRect(gx+5,gy+11,8,10);
    // legs
    g.fillStyle='#ffd1ea'; g.fillRect(gx+7,gy+21,2,4); g.fillRect(gx+9,gy+21,2,4);
    // little heart
    g.fillStyle='#ff6fb3';
    g.fillRect(gx+1, gy+2+(sway|0),1,1); g.fillRect(gx+2, gy+1+(sway|0),1,1); g.fillRect(gx+2, gy+2+(sway|0),1,1);
  }

  // ===== HD rider & girlfriend on the SCREEN canvas =====
  let lastBlit = {dx:0, dy:0, scale:1, dpr:1}; // updated in blit()

  function drawAaronRiderHD(){
    if(!aaronReady) return;
    const {dx,dy,scale,dpr} = lastBlit;
    const sx = dx*dpr + (rocket.x + AARON_OFF_X) * scale * dpr;
    const sy = dy*dpr + (rocket.y + AARON_OFF_Y) * scale * dpr;
    const sw = AARON_W * scale * dpr;
    const sh = AARON_H * scale * dpr;
    const prev = ctx.imageSmoothingEnabled;
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(aaronImg, sx, sy, sw, sh);
    ctx.imageSmoothingEnabled = prev;
  }

  function drawChibiHD(entity){
    if(!entity || !gfReady) return;
    const {dx, dy, scale, dpr} = lastBlit;
    const sx = dx*dpr + (entity.x) * scale * dpr;
    const sy = dy*dpr + (entity.y) * scale * dpr;
    const sw = GF_W * scale * dpr;
    const sh = GF_H * scale * dpr;
    const prev = ctx.imageSmoothingEnabled;
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(gfImg, sx, sy, sw, sh);
    ctx.imageSmoothingEnabled = prev;
  }

  // rendering helpers
  function clear(){ const grd=g.createLinearGradient(0,0,0,H); grd.addColorStop(0,'#14002a'); grd.addColorStop(1,'#2a0a4a'); g.fillStyle=grd; g.fillRect(0,0,W,H); }
  function drawStars(dt,spd){ for(const s of stars){ const p=[0.25,0.5,1.0][s.layer]; s.x-=spd*p*dt; if(s.x<-4) Object.assign(s,newStar()); g.fillStyle=['#4b2a6b','#9d6cff','#e2c6ff'][s.layer]; g.fillRect(s.x|0,s.y|0,1,1);} }
  function drawRocket(){ const {x,y}=rocket; const px=(ix,iy,w,h,c)=>{g.fillStyle=c;g.fillRect((x+ix)|0,(y+iy)|0,w,h);}; px(0,2,10,6,'#b28bff'); px(9,3,3,4,'#e2c6ff'); px(3,4,3,2,'#12001f'); px(0,1,2,2,'#8f5bff'); px(0,7,2,2,'#8f5bff'); const flame=Math.max(0,-rocket.vy*0.8); px(-2,4-(flame>0?1:0),2,2+((flame>2)?1:0),'#ff9ad2'); if(rocket.invuln>0&&((performance.now()%200)|0)<100){ g.globalCompositeOperation='lighter'; px(-1,2,1,6,'#ffffff'); g.globalCompositeOperation='source-over'; } }
  function drawAsteroid(a){ g.fillStyle='#6e49a3'; g.beginPath(); g.arc(a.x|0,a.y|0,a.r|0,0,Math.PI*2); g.fill(); g.fillStyle='#8a68c0'; g.fillRect((a.x-1)|0,(a.y-2)|0,2,2); }
  function drawHUDOverlay(timeLeft){ if(timeLeft<7000){ const k=1-timeLeft/7000; g.fillStyle=`rgba(255,170,255,${0.08+0.25*k})`; g.fillRect(0,H-24,W,24);} }

  function aabb(x,y,w,h, x2,y2,w2,h2){ return x < x2+w2 && x+w > x2 && y < y2+h2 && y+h > y2; }

  // main loop
  function loop(now){
    if(!playing) return;
    const dt=Math.min(40, now-lastFrame); lastFrame=now;
    elapsed = now - startedAt;
    const timeLeft = Math.max(0, DURATION - elapsed);
    const spd = speedAt(elapsed);

    // physics
    rocket.vy += GRAVITY;
    rocket.y  += rocket.vy;
    if(rocket.y<2){ rocket.y=2; rocket.vy=0; }
    if(rocket.y>H-rocket.h-2){ rocket.y=H-rocket.h-2; rocket.vy=0; }
    if(rocket.invuln>0) rocket.invuln -= dt;

    // cosmetics
    maybeAddTrail(now, spd, dt);
    maybeDripSparkles(now);
    updateSparkles(dt, spd);

    // spawning & preview logic
    if (elapsed < DURATION) {
      if (elapsed > START_GRACE && now > nextAsteroidAt) {
        obstacles.push(newAsteroid());
        const interval = asteroidIntervalAt(elapsed);
        nextAsteroidAt = now + interval * (0.7 + Math.random()*0.6);
      }
      // spawn preview in the last 30 seconds (unreachable)
      if (!gfPreview && timeLeft <= GF_PREVIEW_WINDOW) {
        gfPreview = { x: W - 40, y: H/2 - 10, w: GF_W, h: GF_H, sway: 0 };
      }
    } else {
      // AFTER 3:00 -> convert preview to real girlfriend (catchable)
      if (!girlfriend) spawnGirlfriend();
    }

    // keep preview ahead of the rocket (so you can't reach her yet)
    if (gfPreview && !girlfriend) {
      // small float
      gfPreview.sway += 0.05;
      // always stay at least 110px ahead of rocket; never go off-screen
      const minAhead = rocket.x + 110;
      const target = Math.min(W - 40, Math.max(minAhead, gfPreview.x - spd*dt*0.85));
      gfPreview.x = target;
      gfPreview.y = H/2 - 10 + Math.sin(gfPreview.sway)*1.0;
    }

    // move obstacles & score
    for (let i=obstacles.length-1;i>=0;i--){
      const a=obstacles[i];
      a.x -= spd*dt;
      a.y += a.vy;
      if(a.x<-40) obstacles.splice(i,1);
      if(!a.scored && a.x + a.r < rocket.x){ score++; a.scored = true; }
    }

    // draw frame
    drawFrame(dt, spd, timeLeft);

    // collisions (disabled only when real girlfriend exists)
    if(rocket.invuln<=0 && !girlfriend){
      const rb = {x:rocket.x,y:rocket.y,w:rocket.w,h:rocket.h};
      for(const a of obstacles){
        if(aabb(rb.x,rb.y,rb.w,rb.h, a.x-a.r,a.y-a.r,a.r*2,a.r*2)){
          endCrash(); ui(); return;
        }
      }
    }

    // approach her and finish
    if(girlfriend){
      girlfriend.sway += 0.05;
      girlfriend.x -= spd*dt*0.85;
      if(girlfriend.x < rocket.x + 6){
        drawEndingEmbrace(); ui(); endWin(); return;
      }
    }

    ui(timeLeft, spd);
    requestAnimationFrame(loop);
  }

  function drawFrame(dt, spd, timeLeft){
    clear();
    drawPlanets(dt, spd);
    drawNebula(dt, spd);
    drawStars(dt, spd);

    drawTrail();

    for(const a of obstacles){ drawAsteroid(a); }
    // fallback pixel-art if images not loaded yet
    drawGirlfriendFallback(gfPreview);
    drawGirlfriendFallback(girlfriend);

    drawRocket();
    drawSparkles();

    drawHUDOverlay(timeLeft);
    blit();                 // copy low-res ‚Üí screen
    // HD draws (if images ready)
    drawChibiHD(gfPreview);
    drawChibiHD(girlfriend);
    drawAaronRiderHD();
  }

  function drawEndingEmbrace(){
    g.fillStyle='rgba(20,0,42,0.5)'; g.fillRect(0,0,W,H);
    for(let i=0;i<16;i++){ const x=(Math.random()*W)|0, y=(Math.random()*H)|0; g.fillStyle='#ff8ec6'; g.fillRect(x,y,1,1); g.fillRect(x+1,y,1,1); g.fillRect(x,y+1,1,1); }
    blit();
    drawChibiHD(girlfriend);
    drawAaronRiderHD();
  }

  function blit(){
    // Fit buffer into view canvas keeping aspect ratio
    const vw = view.clientWidth, vh = view.clientHeight;
    const scale = Math.min(vw/W, vh/H);
    const dw = (W*scale)|0, dh = (H*scale)|0;
    const dx = ((vw - dw)/2)|0, dy = ((vh - dh)/2)|0;

    const dpr = window.devicePixelRatio || 1;
    if(view.width !== vw*dpr || view.height !== vh*dpr){ view.width = vw*dpr; view.height = vh*dpr; ctx.imageSmoothingEnabled = false; }

    ctx.clearRect(0,0,view.width,view.height);
    ctx.save();
    ctx.imageSmoothingEnabled = false; // keep game pixels crisp
    ctx.drawImage(buffer, 0,0,W,H, dx*dpr, dy*dpr, dw*dpr, dh*dpr);
    ctx.restore();

    // store transform so we can draw HD sprites in exact screen space
    lastBlit = {dx, dy, scale, dpr};
  }

  function ui(timeLeft=Math.max(0,DURATION-(performance.now()-startedAt)), spd=speedAt(elapsed)){
    document.getElementById('score').textContent = score;
    document.getElementById('speed').textContent = ((spd/BASE_SPEED).toFixed(1)+'x');
    document.getElementById('timer').textContent = formatTime(timeLeft);
  }

  // init
  showIntro();
  const hideHint=()=>{ touchHint.style.display='none'; window.removeEventListener('touchstart',hideHint); window.removeEventListener('mousedown',hideHint); };
  window.addEventListener('touchstart',hideHint,{passive:true});
  window.addEventListener('mousedown',hideHint);
})();
</script>
</body>
</html>
