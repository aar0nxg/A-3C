<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel Purple Rocket ‚Äî Love Run</title>
  <style>
    :root { --bg1:#12001f; --bg2:#2a0a4a; --fg:#e2c6ff; --accent:#b28bff; --danger:#ff6fb3; --success:#8dffca; }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";}
    #wrap{position:fixed;inset:0;display:flex;flex-direction:column;}
    #hud{display:flex;gap:.75rem;align-items:center;justify-content:space-between;padding:.75rem 1rem;font-weight:700}
    #hud .pill{background:rgba(255,255,255,.08);padding:.35rem .6rem;border-radius:999px;backdrop-filter: blur(6px); box-shadow: 0 0 0 1px rgba(255,255,255,.05) inset;}
    #game{flex:1;position:relative;}
    canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering: pixelated;image-rendering: crisp-edges;}
    #centerMsg{position:absolute;inset:0;display:none;place-items:center;pointer-events:none;text-align:center;padding:1rem;}
    #centerMsg .card{pointer-events:auto;max-width:680px;background:rgba(42,10,74,.72);border:1px solid rgba(255,255,255,.15);border-radius:18px;padding:18px 16px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
    .btn{cursor:pointer;display:inline-flex;align-items:center;gap:.5rem;padding:.6rem .9rem;border-radius:14px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:var(--fg);font-weight:700}
    .btn:hover{background:rgba(255,255,255,.14)}
    .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:.5rem}
    small{opacity:.85}
    #touchHint{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);opacity:.9;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.18);padding:.4rem .7rem;border-radius:999px;font-weight:700}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="hud">
      <div class="pill">‚è±Ô∏è <span id="timer">03:00</span></div>
      <div class="pill">‚≠ê Score: <span id="score">0</span></div>
      <div class="pill">üöÄ Speed: <span id="speed">1.0x</span></div>
      <div class="pill">üïπÔ∏è Controls: <span id="controls">Space / Tap</span></div>
    </div>
    <div id="game">
      <canvas id="c"></canvas>
      <div id="centerMsg"><div class="card" id="centerCard"></div></div>
      <div id="touchHint">TAP to thrust</div>
    </div>
  </div>

<script>
(() => {
  // ====== pixel canvas ======
  const view = document.getElementById('c');
  const ctx = view.getContext('2d');
  const W = 320, H = 180;
  const buffer = document.createElement('canvas'); buffer.width=W; buffer.height=H;
  const g = buffer.getContext('2d'); g.imageSmoothingEnabled=false; ctx.imageSmoothingEnabled=false;

  // ====== constants ======
  const DURATION = 180000; // EXACTLY 3 minutes
  const GRAVITY = 0.28;
  const FLAP = -5.4;

  // Slower overall feel (approved)
  const BASE_SPEED = 0.42;            // gentler start
  const MAX_SPEED  = 2.0;             // lower top speed
  const ASTEROID_INTERVAL_MIN = 750;  // fewer spawns at peak
  const ASTEROID_INTERVAL_MAX = 2100; // fewer spawns early

  const START_GRACE = 1500;    // first 1.5s: no asteroids
  const ROCKET_X = 56;

  // --- Visual parallax layers (no gameplay impact) ---
  const NEBULA_COUNT   = 6;      // soft fog blobs
  const PLANET_COUNT   = 2;      // distant planets
  const NEBULA_PARALLAX = 0.18;  // slow drift
  const PLANET_PARALLAX = 0.10;  // slower drift

  // --- Foreground FX (visual only) ---
  const TRAIL_MAX = 42;                 // max trail points
  const TRAIL_SPAWN_INTERVAL = 40;      // ms between trail dots
  const SPARKLE_BURST = 12;             // on tap/flap
  const SPARKLE_DRIP = 2;               // while thrusting (vy < 0)
  const SPARKLE_INTERVAL = 60;          // ms between drip spawns

  // --- Rider (visual only) ---
  const AARON_SRC = "aaron.jpg";  // ensure the file name matches
  const AARON_W   = 12;           // rider width (game pixels)
  let   AARON_H   = 12;           // height auto-set by aspect
  const AARON_OFF_X = 3;          // offset from rocket.x
  const AARON_OFF_Y = -6;         // offset from rocket.y
  const aaronImg = new Image();
  let aaronReady = false;
  aaronImg.onload = () => {
    const ratio = aaronImg.height / aaronImg.width;
    AARON_H = Math.max(1, Math.round(AARON_W * ratio));
    aaronReady = true;
  };
  aaronImg.src = AARON_SRC;

  // ====== state ======
  let playing=false, finished=false, crashed=false, startedAt=0, elapsed=0, lastFrame=0;
  let score=0;
  let rocket={x:ROCKET_X,y:H/2,vy:0,w:16,h:10,invuln:0};
  let obstacles=[]; let stars=[]; let nextAsteroidAt=0;
  let girlfriend=null; // appears ONLY after 3:00
  // visual layers
  let nebula = [];
  let planets = [];
  // fx
  let trail = [];
  let sparkles = [];
  let lastTrailAt = 0;
  let nextSparkleAt = 0;

  // ====== ui ======
  const uiTimer=document.getElementById('timer');
  const uiScore=document.getElementById('score');
  const uiSpeed=document.getElementById('speed');
  const centerMsg=document.getElementById('centerMsg');
  const centerCard=document.getElementById('centerCard');
  const touchHint=document.getElementById('touchHint');

  // inputs
  window.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); flap(); }});
  window.addEventListener('touchstart', ()=>flap(), {passive:true});
  window.addEventListener('mousedown', ()=>flap());

  function flap(){
    if(!playing && !finished){ start(); }
    if(playing){
      rocket.vy = FLAP;
      spawnThrustBurst(); // visual only
    }
  }

  // overlay helpers
  function showCenter(html){ centerCard.innerHTML=html; centerMsg.style.display='grid'; }
  function hideCenter(){ centerMsg.style.display='none'; centerCard.innerHTML=''; }

  // screens
  function showIntro(){
    const html = `
      <h2 style="margin:4px 0 10px">üíú Pixel Purple Rocket ‚Äî Love Run</h2>
      <p style="margin:0 0 8px">Fly for <b>3 minutes</b>, dodge asteroids, then after 3:00 your girlfriend appears ‚Äî reach her to win.</p>
      <div class="row"><button class="btn" id="btnStart">Start (Space/Tap)</button><button class="btn" id="btnHow">How to Play</button></div>
      <small>Mobile friendly ‚Ä¢ Pixel-art vibes ‚Ä¢ Ramps steadily</small>`;
    showCenter(html);
    document.getElementById('btnStart').onclick=()=>start();
    document.getElementById('btnHow').onclick =()=>showHow();
  }
  function showHow(){
    const html=`<h3>Controls</h3>
    <ul style="text-align:left;line-height:1.5">
      <li><b>Space</b> (desktop) or <b>tap</b> (phone) to thrust up</li>
      <li>Release to fall ‚Ä¢ Avoid asteroids</li>
      <li>Timer hits 0:00 ‚Üí she appears ‚Ä¢ Reach her to win</li>
    </ul>
    <div class="row"><button class="btn" id="btnBack">Back</button></div>`;
    showCenter(html);
    document.getElementById('btnBack').onclick=()=>showIntro();
  }
  function showCrash(){ const html=`<h2>üí• Oops! You crashed</h2><p>Score: <b>${score}</b></p><div class="row"><button class="btn" id="btnRetry">Try Again</button></div>`; showCenter(html); document.getElementById('btnRetry').onclick=()=>start(); }
  function showWin(){ const html=`<h2>üíû You made it!</h2><p>You reached her after a 3-minute run. Score: <b>${score}</b></p><div class="row"><button class="btn" id="btnReplay">Replay</button></div>`; showCenter(html); document.getElementById('btnReplay').onclick=()=>start(); }

  // start/end
  function start(){
    hideCenter(); touchHint.style.display='none';
    playing=true; crashed=false; finished=false;
    score=0; obstacles=[]; stars=[]; girlfriend=null;
    nebula=[]; planets=[];
    trail=[]; sparkles=[]; lastTrailAt=0; nextSparkleAt=0;

    rocket.y=H/2; rocket.vy=0; rocket.invuln=800;
    startedAt=performance.now(); lastFrame=startedAt; elapsed=0; nextAsteroidAt=0;

    // seed stars
    for(let i=0;i<80;i++) stars.push(newStar(Math.random()*W, Math.random()*H));
    // seed visual layers
    for (let i=0;i<NEBULA_COUNT;i++) nebula.push(newNebula(Math.random()*W, Math.random()*H));
    for (let i=0;i<PLANET_COUNT;i++) planets.push(newPlanet(Math.random()*W, 20 + Math.random()*(H-40)));

    requestAnimationFrame(loop);
  }
  function endWin(){ playing=false; finished=true; showWin(); }
  function endCrash(){ playing=false; crashed=true; showCrash(); }

  // helpers
  // smoother ramp (keep same start/end speeds)
  function speedAt(t){
    const k = Math.min(1, t / DURATION);
    const eased = k * k; // quadratic easing: slower early, faster late
    return BASE_SPEED + (MAX_SPEED - BASE_SPEED) * eased;
  }
  function asteroidIntervalAt(t){ const k=Math.min(1,t/DURATION); return ASTEROID_INTERVAL_MAX + (ASTEROID_INTERVAL_MIN - ASTEROID_INTERVAL_MAX)*k; }
  function formatTime(ms){ const s=Math.ceil(Math.max(0,ms)/1000); const m=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }

  function newStar(x=W+8,y=Math.random()*H){ const layer=Math.random()<0.6?0:(Math.random()<0.5?1:2); return {x,y,layer}; }
  function newAsteroid(){ const r=6+Math.random()*10; const y=12+Math.random()*(H-24); const vy=(Math.random()*0.6-0.3); return {x:W+20,y,r,vy,scored:false}; }
  function spawnGirlfriend(){ girlfriend={x: W+60, y: H/2-10, w:18, h:26, sway:0}; }

  // ======= Visual Layer Helpers (purely cosmetic) =======
  function newNebula(x = W + 40, y = Math.random()*H) {
    const r  = 26 + Math.random()*42;     // radius
    const a  = 0.08 + Math.random()*0.12; // alpha
    const wobble = Math.random()*Math.PI*2;
    return { x, y, r, a, wobble };
  }
  function drawNebula(dt, spd){
    for (let i = nebula.length-1; i >= 0; i--) {
      const n = nebula[i];
      n.x -= spd * NEBULA_PARALLAX * dt;
      n.wobble += 0.004;
      const rr = n.r + Math.sin(n.wobble)*2.0;
      const grad = g.createRadialGradient(n.x, n.y, 0, n.x, n.y, rr);
      grad.addColorStop(0, `rgba(178,139,255,${n.a})`);
      grad.addColorStop(1, `rgba(178,139,255,0)`);
      g.fillStyle = grad;
      g.beginPath();
      g.arc(n.x|0, n.y|0, rr|0, 0, Math.PI*2);
      g.fill();
      if (n.x < -rr - 10) nebula.splice(i,1);
    }
    while (nebula.length < NEBULA_COUNT) nebula.push(newNebula());
  }

  function newPlanet(x = W + 80, y = 30 + Math.random()*(H-60)) {
    const r  = 10 + Math.random()*14;
    const ring = Math.random() < 0.5;
    const hue = Math.random() < 0.5 ? '#6e49a3' : '#8a68c0';
    return { x, y, r, ring, hue };
  }
  function drawPlanets(dt, spd){
    for (let i = planets.length-1; i >= 0; i--) {
      const p = planets[i];
      p.x -= spd * PLANET_PARALLAX * dt;

      // softer transparency so they don't read like obstacles
      g.fillStyle = `${p.hue}aa`; // ~67% alpha; use '80' for ~50% if desired
      g.beginPath(); g.arc(p.x|0, p.y|0, p.r|0, 0, Math.PI*2); g.fill();

      // simple terminator shadow
      g.fillStyle = 'rgba(0,0,0,0.25)';
      g.beginPath(); g.arc((p.x+2)|0, (p.y+1)|0, p.r|0, Math.PI*0.1, Math.PI*1.1); g.fill();
      if (p.ring) {
        g.strokeStyle = 'rgba(226,198,255,0.45)';
        g.lineWidth = 1;
        g.beginPath(); g.ellipse(p.x|0, p.y|0, p.r+3, p.r*0.45, 0.25, 0, Math.PI*2); g.stroke();
      }
      if (p.x < -p.r - 20) planets.splice(i,1);
    }
    while (planets.length < PLANET_COUNT) planets.push(newPlanet());
  }

  // ===== Visual FX: trail & sparkles (no gameplay impact) =====
  function maybeAddTrail(now, spd, dt){
    if (now - lastTrailAt >= TRAIL_SPAWN_INTERVAL){
      trail.push({ x: rocket.x - 3, y: rocket.y + 5, r: 2, a: 1 });
      lastTrailAt = now;
      if (trail.length > TRAIL_MAX) trail.shift();
    }
    for (let i = trail.length - 1; i >= 0; i--){
      const p = trail[i];
      p.x -= spd * dt * 0.6;
      p.y += 0.02 * dt;
      p.r += 0.005 * dt;
      p.a -= 0.0035 * dt;
      if (p.a <= 0 || p.x < -10) trail.splice(i, 1);
    }
  }
  function drawTrail(){
    for (const p of trail){
      g.fillStyle = `rgba(255,154,210,${0.50 * Math.max(0, p.a)})`;
      g.fillRect(p.x|0, p.y|0, 2, 2);
      g.fillStyle = `rgba(178,139,255,${0.35 * Math.max(0, p.a)})`;
      g.fillRect((p.x-1)|0, (p.y+1)|0, 1, 1);
    }
  }
  function spawnThrustBurst(){
    for (let i = 0; i < SPARKLE_BURST; i++){
      sparkles.push({
        x: rocket.x - 2,
        y: rocket.y + 5,
        vx: -0.02 - Math.random()*0.10,
        vy: (Math.random()*0.5 - 0.25),
        life: 450 + Math.random()*300,
        a: 1
      });
    }
  }
  function maybeDripSparkles(now){
    if (rocket.vy < 0 && now >= nextSparkleAt){
      nextSparkleAt = now + SPARKLE_INTERVAL;
      for (let i = 0; i < SPARKLE_DRIP; i++){
        sparkles.push({
          x: rocket.x - 2,
          y: rocket.y + 5,
          vx: -0.02 - Math.random()*0.06,
          vy: (Math.random()*0.4 - 0.2),
          life: 380 + Math.random()*220,
          a: 1
        });
      }
    }
  }
  function updateSparkles(dt, spd){
    for (let i = sparkles.length - 1; i >= 0; i--){
      const s = sparkles[i];
      s.x += s.vx * dt - spd * dt * 0.5;
      s.y += s.vy * dt;
      s.vy += 0.0006 * dt;
      s.life -= dt;
      s.a = Math.max(0, s.life / 450);
      if (s.life <= 0 || s.x < -10) sparkles.splice(i, 1);
    }
  }
  function drawSparkles(){
    for (const s of sparkles){
      g.fillStyle = `rgba(255,142,198,${0.9*s.a})`;
      g.fillRect(s.x|0, s.y|0, 1, 1);
      g.fillStyle = `rgba(226,198,255,${0.6*s.a})`;
      g.fillRect((s.x+1)|0, s.y|0, 1, 1);
    }
  }

  // ===== Rider draw (visual only) =====
  function drawAaronRider(){
    if(!aaronReady) return;
    const rx = (rocket.x + AARON_OFF_X) | 0;
    const ry = (rocket.y + AARON_OFF_Y) | 0;
    const prev = g.imageSmoothingEnabled;
    g.imageSmoothingEnabled = true; // smooth Aaron image only
    g.drawImage(aaronImg, rx, ry, AARON_W, AARON_H);
    g.imageSmoothingEnabled = prev;
  }

  // rendering
  function clear(){ const grd=g.createLinearGradient(0,0,0,H); grd.addColorStop(0,'#14002a'); grd.addColorStop(1,'#2a0a4a'); g.fillStyle=grd; g.fillRect(0,0,W,H); }
  function drawStars(dt,spd){ for(const s of stars){ const p=[0.25,0.5,1.0][s.layer]; s.x-=spd*p*dt; if(s.x<-4) Object.assign(s,newStar()); g.fillStyle=['#4b2a6b','#9d6cff','#e2c6ff'][s.layer]; g.fillRect(s.x|0,s.y|0,1,1);} }
  function drawRocket(){ const {x,y}=rocket; const px=(ix,iy,w,h,c)=>{g.fillStyle=c;g.fillRect((x+ix)|0,(y+iy)|0,w,h);}; px(0,2,10,6,'#b28bff'); px(9,3,3,4,'#e2c6ff'); px(3,4,3,2,'#12001f'); px(0,1,2,2,'#8f5bff'); px(0,7,2,2,'#8f5bff'); const flame=Math.max(0,-rocket.vy*0.8); px(-2,4-(flame>0?1:0),2,2+((flame>2)?1:0),'#ff9ad2'); if(rocket.invuln>0&&((performance.now()%200)|0)<100){ g.globalCompositeOperation='lighter'; px(-1,2,1,6,'#ffffff'); g.globalCompositeOperation='source-over'; } }
  function drawAsteroid(a){ g.fillStyle='#6e49a3'; g.beginPath(); g.arc(a.x|0,a.y|0,a.r|0,0,Math.PI*2); g.fill(); g.fillStyle='#8a68c0'; g.fillRect((a.x-1)|0,(a.y-2)|0,2,2); }
  function drawGirlfriend(){ if(!girlfriend) return; const gx=girlfriend.x|0, gy=girlfriend.y|0; girlfriend.sway+=0.05; const sway=Math.sin(girlfriend.sway)*1.2; g.fillStyle='#2b0f46'; g.fillRect(gx+4,gy+1,10,8); g.fillStyle='#ffd1ea'; g.fillRect(gx+6,gy+4,6,6); g.fillStyle='#2b0f46'; g.fillRect(gx+7,gy+6,1,1); g.fillRect(gx+10,gy+6,1,1); g.fillStyle='#b28bff'; g.fillRect(gx+5,gy+11,8,10); g.fillStyle='#ffd1ea'; g.fillRect(gx+7,gy+21,2,4); g.fillRect(gx+9,gy+21,2,4); g.fillStyle='#ff6fb3'; g.fillRect(gx+1,gy+2+(sway|0),1,1); g.fillRect(gx+2,gy+1+(sway|0),1,1); g.fillRect(gx+2,gy+2+(sway|0),1,1); }
  function drawHUDOverlay(timeLeft){ if(timeLeft<7000){ const k=1-timeLeft/7000; g.fillStyle=`rgba(255,170,255,${0.08+0.25*k})`; g.fillRect(0,H-24,W,24);} }

  function aabb(x,y,w,h,x2,y2,w2,h2){ return x<x2+w2 && x+w>x2 && y<y2+h2 && y+h>y2; }
  function rocketBox(){ return {x:rocket.x,y:rocket.y,w:rocket.w,h:rocket.h}; }

  // main loop
  function loop(now){
    if(!playing) return;
    const dt=Math.min(40, now-lastFrame); lastFrame=now;
    elapsed = now - startedAt;
    const timeLeft = Math.max(0, DURATION - elapsed);
    const spd = speedAt(elapsed);

    // physics
    rocket.vy += GRAVITY;
    rocket.y  += rocket.vy;
    if(rocket.y<2){ rocket.y=2; rocket.vy=0; }
    if(rocket.y>H-rocket.h-2){ rocket.y=H-rocket.h-2; rocket.vy=0; }
    if(rocket.invuln>0) rocket.invuln -= dt;

    // --- visual FX updates (no gameplay impact) ---
    maybeAddTrail(now, spd, dt);
    maybeDripSparkles(now);
    updateSparkles(dt, spd);

    // spawning: during the 3 minutes (except first 1.5s)
    if (elapsed < DURATION) {
      if (elapsed > START_GRACE && now > nextAsteroidAt) {
        obstacles.push(newAsteroid());
        const interval = asteroidIntervalAt(elapsed);
        nextAsteroidAt = now + interval * (0.7 + Math.random()*0.6);
      }
    } else {
      // AFTER 3:00: stop spawning & show girlfriend
      if (!girlfriend) spawnGirlfriend();
    }

    // move obstacles & score
    for (let i=obstacles.length-1;i>=0;i--){
      const a=obstacles[i];
      a.x -= spd*dt;
      a.y += a.vy;
      if(a.x<-40) obstacles.splice(i,1);
      if(!a.scored && a.x + a.r < rocket.x){ score++; a.scored = true; }
    }

    // draw frame
    drawFrame(dt, spd, timeLeft);

    // collisions (disabled once girlfriend appears)
    if(rocket.invuln<=0 && !girlfriend){
      const rb=rocketBox();
      for(const a of obstacles){
        if(aabb(rb.x,rb.y,rb.w,rb.h, a.x-a.r,a.y-a.r,a.r*2,a.r*2)){
          endCrash(); ui(); return;
        }
      }
    }

    // after 3:00, approach her and finish by touching her
    if(girlfriend){
      girlfriend.x -= spd*dt*0.85; // slightly slower so you catch up
      if(girlfriend.x < rocket.x + 6){
        drawEndingEmbrace(); ui(); endWin(); return;
      }
    }

    ui(timeLeft, spd);
    requestAnimationFrame(loop);
  }

  function drawFrame(dt, spd, timeLeft){
    clear();
    drawPlanets(dt, spd);   // far layer
    drawNebula(dt, spd);    // behind stars
    drawStars(dt, spd);

    drawTrail();            // behind obstacles/rocket

    for(const a of obstacles){ drawAsteroid(a); }
    if(girlfriend) drawGirlfriend();
    drawRocket();

    drawAaronRider();       // mini Aaron rides the rocket

    drawSparkles();         // in front of rocket

    drawHUDOverlay(timeLeft);
    blit();
  }

  function drawEndingEmbrace(){
    g.fillStyle='rgba(20,0,42,0.5)'; g.fillRect(0,0,W,H);
    for(let i=0;i<16;i++){ const x=(Math.random()*W)|0, y=(Math.random()*H)|0; g.fillStyle='#ff8ec6'; g.fillRect(x,y,1,1); g.fillRect(x+1,y,1,1); g.fillRect(x,y+1,1,1); }
    blit();
  }

  function blit(){
    const vw=view.clientWidth, vh=view.clientHeight;
    const scale=Math.min(vw/W, vh/H);
    const dw=(W*scale)|0, dh=(H*scale)|0;
    const dx=((vw-dw)/2)|0, dy=((vh-dh)/2)|0;
    const dpr=window.devicePixelRatio||1;
    if(view.width!==vw*dpr || view.height!==vh*dpr){ view.width=vw*dpr; view.height=vh*dpr; ctx.imageSmoothingEnabled=false; }
    ctx.clearRect(0,0,view.width,view.height);
    ctx.save(); ctx.imageSmoothingEnabled=false;
    ctx.drawImage(buffer,0,0,W,H, dx*dpr,dy*dpr,dw*dpr,dh*dpr);
    ctx.restore();
  }
  function ui(timeLeft=Math.max(0,DURATION-(performance.now()-startedAt)), spd=speedAt(elapsed)){
    uiScore.textContent = score;
    uiSpeed.textContent = ((spd/BASE_SPEED).toFixed(1)+'x');
    uiTimer.textContent = formatTime(timeLeft);
  }

  // init
  showIntro();
  const hideHint=()=>{ touchHint.style.display='none'; window.removeEventListener('touchstart',hideHint); window.removeEventListener('mousedown',hideHint); };
  window.addEventListener('touchstart',hideHint,{passive:true});
  window.addEventListener('mousedown',hideHint);
})();
</script>
</body>
</html>
